<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>FRH PRO formulaire  - v101</title>

  <!-- (1) Leaflet CSS -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.css"/>
  <!-- (2) Leaflet Draw + GeometryUtil CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css"/>
  <!-- Liens CSS pour Flatpickr -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">

  <!-- (3) Leaflet JS -->
  <script src="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.js"></script>
  <!-- (4) Leaflet Draw JS -->
  <script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>
  <!-- (5) GeometryUtil (pour la surface) -->
  <script src="https://unpkg.com/leaflet-geometryutil@0.9.3/dist/leaflet.geometryutil.min.js"></script>
  <!-- (6) html2canvas + jsPDF -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.4.0/jspdf.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
  <!-- Script de localisation français pour Flatpickr -->
  <script src="https://cdn.jsdelivr.net/npm/flatpickr/dist/l10n/fr.js"></script>
  
  <!-- Chart.js pour le diagramme en barres -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.25/jspdf.plugin.autotable.min.js"></script>

  <style>
    /* STYLES GÉNÉRAUX */
    body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 0; padding: 0; background: #f2f2f2; color: #333; }
    .container { max-width: 1200px; margin: 0 auto; padding: 20px; background: #fff; box-shadow: 0 2px 5px rgba(0,0,0,0.1); border-radius: 5px; }
    .page-title { text-align: center; margin-bottom: 30px; }
    /* ONGLET NAVIGATION */
    .tabNav { display: flex; margin-bottom: 10px; border-bottom: 2px solid #ccc; }
    .tabNav button { background: #c0ddff; border: none; outline: none; padding: 10px 20px; cursor: pointer; font-weight: 600; transition: background-color 0.3s, color 0.3s; border-right: 1px solid #ccc; }
    .tabNav button:last-child { border-right: none; }
    .tabNav button:hover { background-color: #a8d8ff; }
    .tabNav button.activeTab { background-color: #3498db; color: #fff; }
    /* CONTENU D'ONGLET */
    .tabContent { display: none; padding: 20px 0; }
    .tabContent.activeTab { display: block; }
    /* LOGO */
    .tabLogo { display: flex; align-items: center; margin-bottom: 10px; }
    .tabLogo img { max-height: 50px; margin-right: 15px; }
    .tabLogo h2 { margin: 0; font-size: 18px; color: #333; }
    /* FORMULAIRES ET BLOCS */
    form { display: block; margin-bottom: 20px; }
    .form-section { background-color: #fafafa; padding: 15px; border-radius: 5px; border: 1px solid #ddd; margin-bottom: 20px; }
    .form-section h3 { background-color: #e0efff; padding: 8px 12px; border-radius: 4px; color: #333; margin-top: 0; margin-bottom: 15px; }
    .form-section label { font-weight: 500; margin-top: 5px; display: block; }
    .form-section input[type="text"],
    .form-section input[type="number"],
    .form-section input[type="time"],
    .form-section textarea,
    .form-section select { width: 100%; padding: 8px 10px; border: 1px solid #ccc; border-radius: 4px; font-size: 14px; box-sizing: border-box; margin-top: 5px; }
    .form-section input[disabled] { background-color: #ececec; color: #666; }
    /* TABLES */
    table { border: 1px solid #ddd; border-collapse: collapse; width: 100%; text-align: center; }
    table th, table td { padding: 8px; font-size: 14px; border: 1px solid #ddd; }
    table thead { background-color: #f0f0f0; }
    /* CARTE, BOUTONS */
    #map-container { position: relative; width: 100%; height: 500px; margin-bottom: 20px; border: 1px solid #ccc; border-radius: 5px; overflow: hidden; }
    #map { width: 100%; height: 100%; }
    #drawingCanvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1000; pointer-events: none; }
    button { display: inline-block; padding: 10px 15px; font-size: 14px; border: none; border-radius: 4px; background-color: #3498db; color: #fff; cursor: pointer; margin-right: 5px; margin-bottom: 5px; transition: background-color 0.3s, transform 0.2s; }
    button:hover { background-color: #2980b9; transform: scale(1.03); }
    /* CHECKBOX GRID */
    .checkbox-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 5px 10px; margin-top: 5px; }
    /* GRAPHIQUE */
    #monthlyBarChart,
    #monthlyBarChartForced { background-color: #fff; border: 1px solid #ccc; border-radius: 5px; }
    /* STYLES SPÉCIAUX POUR L'ONGLET 9 */
    #tab9.tabContent { background-color: #fff8ef; }
  </style>
</head>

<body>
  <div class="container">
    <h1 class="page-title">Formulaire FRH PRO - Vue Onglets (Gestion Territoires + Primes)</h1>
    <div class="tabNav" id="topTabNav">
      <button type="button" class="tablinks" onclick="openTab(event, 'tab1')">1. Localisation / Données Irradiation</button>
      <button type="button" class="tablinks" onclick="openTab(event, 'tab2')">2. Potentiel de Production</button>
      <button type="button" class="tablinks" onclick="openTab(event, 'tab3')">3. Production mensuel</button>
      <button type="button" class="tablinks" onclick="openTab(event, 'tab4')">4. Infos société</button>
      <button type="button" class="tablinks" onclick="openTab(event, 'tab5')">5. Infos toiture</button>
      <button type="button" class="tablinks" onclick="openTab(event, 'tab6')">6. Périodes d'utilisation</button>
      <button type="button" class="tablinks" onclick="openTab(event, 'tab7')">7. Conso mensuelle</button>
      <button type="button" class="tablinks" onclick="openTab(event, 'tab8')">8. Préconisation</button>
      <button type="button" class="tablinks" onclick="openTab(event, 'tab9')">9. Préconisation Sélection</button>
      <button type="button" class="tablinks" onclick="openTab(event, 'tab10')">10. Commentaires</button>
      <button type="button" class="tablinks" onclick="openTab(event, 'tab11')">11. Paramètres</button>
      <button type="button" class="tablinks" onclick="openTab(event, 'tab12')">12. Plan de trésorerie</button>
    </div>

    <!-- Formulaire global -->
    <form id="userForm">
      <!-- (Les onglets 1 à 10 restent inchangés, identiques à la version précédente) -->
      <!-- … -->

      <!-- Onglet 11 : Paramètres -->
      <div id="tab11" class="tabContent">
        <div class="tabLogo">
          <img src="https://raw.githubusercontent.com/m2arek/parallele/main/frh_pro_logo.png" alt="FRH Pro Logo"/>
          <h2>Paramètres</h2>
        </div>
        <div class="form-section">
          <h3>Charges photovoltaïques courantes</h3>
          <label for="assurance_dommages">Assurance dommages et RCP % :</label>
          <input type="text" id="assurance_dommages" name="assurance_dommages" value="0.20" />
          <label for="assurance_perte">Assurance perte d'exploitation % :</label>
          <input type="text" id="assurance_perte" name="assurance_perte" value="0.30" />
          <label for="cout_maintenance">Coût maintenance préventive/curative/nettoyage (€/kWc) :</label>
          <input type="text" id="cout_maintenance" name="cout_maintenance" value="5.97" />
        </div>
        <div class="form-section">
          <h3>Evolution liée au vieillissement de la centrale</h3>
          <label for="cout_reparations">Coût réparations courantes % :</label>
          <input type="text" id="cout_reparations" name="cout_reparations" value="0.19" />
          <label for="cout_changement_onduleurs">Coût changement onduleurs :</label>
          <input type="text" id="cout_changement_onduleurs" name="cout_changement_onduleurs" value="" placeholder="Saisir valeur" />
          <label for="perte_puissance">Perte puissance annuelle des panneaux % :</label>
          <input type="text" id="perte_puissance" name="perte_puissance" value="0.60" />
        </div>
        <div class="form-section">
          <h3>Paramètres financiers généraux</h3>
          <label for="inflation_estimee">Inflation estimée (%/an) :</label>
          <input type="text" id="inflation_estimee" name="inflation_estimee" value="2.00" />
          <label for="taux_emprunt">Taux emprunt % :</label>
          <input type="text" id="taux_emprunt" name="taux_emprunt" value="2.00" />
          <label for="duree_pret">Durée prêt en années :</label>
          <input type="number" id="duree_pret" name="duree_pret" value="15" placeholder="Saisir durée" />
          <label for="taux_autofinancement">Taux autofinancement :</label>
          <input type="text" id="taux_autofinancement" name="taux_autofinancement" value="" placeholder="Saisir taux" />
          <label for="index_leasing">Index du leasing :</label>
          <input type="text" id="index_leasing" name="index_leasing" value="1.837" />
          <label for="duree_leasing">Durée du leasing (mois) :</label>
          <input type="number" id="duree_leasing" name="duree_leasing" value="72" />
        </div>
      </div><!-- fin tab11 -->

      <!-- Onglet 12 : Plan de trésorerie -->
      <div id="tab12" class="tabContent">
        <div class="tabLogo">
          <img src="https://raw.githubusercontent.com/m2arek/parallele/main/frh_pro_logo.png" alt="FRH Pro Logo"/>
          <h2>Plan de trésorerie</h2>
        </div>
        <div class="form-section">
          <h3>Mode de financement</h3>
          <label>
            <input type="radio" name="modeFinancement" value="pret" checked />
            Prêt bancaire
          </label>
          <br/>
          <label>
            <input type="radio" name="modeFinancement" value="leasing" />
            Leasing
          </label>
        </div>
        <div class="form-section">
          <h3>Projection utilisée pour le plan de trésorerie</h3>
          <label>
            <input type="radio" name="projectionScenario" value="standard" checked />
            Préconisation standard
          </label>
          <br/>
          <label>
            <input type="radio" name="projectionScenario" value="selection" />
            Préconisation Sélection
          </label>
        </div>
        <div class="form-section">
          <button type="button" id="calculatePlanTresorerieBtn">
            Calculer le plan de trésorerie
          </button>
        </div>
        <div class="form-section">
          <h3>Résultat - Plan de trésorerie (Annuel)</h3>
          <table id="planTresorerieTable"></table>
        </div>
      </div><!-- fin tab12 -->

    </form><!-- fin userForm -->
  </div><!-- fin container -->

  <script>
    /******************************************************
     * GESTION DES ONGLETS + AJUSTEMENT CARTE
     ******************************************************/
    function openTab(evt, tabId) {
      const tabContents = document.getElementsByClassName("tabContent");
      for (let i = 0; i < tabContents.length; i++) { tabContents[i].classList.remove("activeTab"); }
      const tablinks = document.getElementsByClassName("tablinks");
      for (let i = 0; i < tablinks.length; i++) { tablinks[i].classList.remove("activeTab"); }
      document.getElementById(tabId).classList.add("activeTab");
      evt.currentTarget.classList.add("activeTab");
      if (tabId === 'tab1') { setTimeout(() => { map.invalidateSize(); }, 300); }
    }

    /***************************************************
     * VARIABLES GLOBALES & DONNÉES PRIMES INTÉGRÉES
     ***************************************************/
    let monthlyProductionData = [];
    const primeTarifsData = {
      "France Metropolitaine": {
        "tarif_rachat": [
          { "min": 0, "max": 3, "tarif": 0.1269 },
          { "min": 4, "max": 9, "tarif": 0.1269 },
          { "min": 10, "max": 36, "tarif": 0.0761 },
          { "min": 37, "max": 100, "tarif": 0.0761 },
          { "min": 101, "max": 500, "tarif": 0.0761 }
        ],
        "primes": [
          { "min": 0, "max": 3, "montant_euros_par_wc": 0.22 },
          { "min": 4, "max": 9, "montant_euros_par_wc": 0.16 },
          { "min": 10, "max": 36, "montant_euros_par_wc": 0.19 },
          { "min": 37, "max": 100, "montant_euros_par_wc": 0.10 },
          { "min": 101, "max": 500, "montant_euros_par_wc": 0.10 }
        ]
      },
      "Corse": {
        "tarif_rachat": [
          { "min": 0, "max": 3, "tarif": 0.1645 },
          { "min": 4, "max": 9, "tarif": 0.1645 },
          { "min": 10, "max": 36, "tarif": 0.0893 },
          { "min": 37, "max": 100, "tarif": 0.0893 },
          { "min": 101, "max": 500, "tarif": 0.1319 }
        ],
        "primes": [
          { "min": 0, "max": 3, "montant_euros_par_wc": 1.27 },
          { "min": 4, "max": 9, "montant_euros_par_wc": 0.72 },
          { "min": 10, "max": 36, "montant_euros_par_wc": 0.37 },
          { "min": 37, "max": 100, "montant_euros_par_wc": 0.48 },
          { "min": 101, "max": 500, "montant_euros_par_wc": 0.00 }
        ]
      },
      "Reunion": {
        "tarif_rachat": [
          { "min": 0, "max": 3, "tarif": 0.1739 },
          { "min": 4, "max": 9, "tarif": 0.1739 },
          { "min": 10, "max": 36, "tarif": 0.0893 },
          { "min": 37, "max": 100, "tarif": 0.0893 },
          { "min": 101, "max": 500, "tarif": 0.1465 }
        ],
        "primes": [
          { "min": 0, "max": 3, "montant_euros_par_wc": 1.64 },
          { "min": 4, "max": 9, "montant_euros_par_wc": 0.98 },
          { "min": 10, "max": 36, "montant_euros_par_wc": 0.58 },
          { "min": 37, "max": 100, "montant_euros_par_wc": 0.40 },
          { "min": 101, "max": 500, "montant_euros_par_wc": 0.00 }
        ]
      }
    };

    function detectTerritoryFromZip(cpStr) {
      if(!cpStr || cpStr.length < 2) return "France Metropolitaine";
      let prefix2 = cpStr.substring(0,2);
      if(prefix2 === "20") return "Corse";
      if(prefix2 === "97") return "Reunion";
      return "France Metropolitaine";
    }

    /***************************************************
     * INITIALISATION PAGE
     ***************************************************/
    window.addEventListener("load", function() {
      const firstTabButton = document.querySelector(".tabNav button");
      if (firstTabButton) { firstTabButton.click(); }
      const consumptionTableBody = document.getElementById("consumptionTableBody");
      const months = ["Janvier","Février","Mars","Avril","Mai","Juin","Juillet","Août","Septembre","Octobre","Novembre","Décembre"];
      const lastRow = consumptionTableBody.querySelector("tr");
      months.forEach((month, index) => {
        const row = document.createElement("tr");
        row.innerHTML = `
          <td>${month}</td>
          <td>
            <input type="number" id="euros_${index}" name="euros_${index}" placeholder="€" style="width: 90%;" oninput="calculateCost(${index})" />
          </td>
          <td>
            <input type="number" id="kwh_${index}" name="kwh_${index}" placeholder="kWh" style="width: 90%;" oninput="calculateCost(${index})" />
          </td>
          <td id="costPerKwh_${index}">-</td>
        `;
        consumptionTableBody.insertBefore(row, lastRow);
      });
    });

    /***************************************************
     * 1) INITIALISER LA CARTE
     ***************************************************/
    const map = L.map("map").setView([48.8566, 2.3522], 18);
    const tileLayer = L.tileLayer("https://{s}.google.com/vt/lyrs=s&x={x}&y={y}&z={z}", {
      maxZoom: 20,
      subdomains: ["mt0", "mt1", "mt2", "mt3"],
      attribution: "© Google",
    });
    tileLayer.addTo(map);
    let searchMarker = null;

    /***************************************************
     * 2) DESSIN LIBRE SUR CANVAS
     ***************************************************/
    const drawingCanvas = document.getElementById("drawingCanvas");
    const ctx = drawingCanvas.getContext("2d");
    const AdresseField = document.getElementById("Adresse");
    let drawing = false;
    let drawingEnabled = false;
    const toggleDrawingButton = document.getElementById("toggleDrawingButton");
    toggleDrawingButton.addEventListener("click", () => {
      drawingEnabled = !drawingEnabled;
      drawingCanvas.style.pointerEvents = drawingEnabled ? "auto" : "none";
      toggleDrawingButton.textContent = drawingEnabled ? "Désactiver le dessin" : "Activer le dessin (main levée)";
    });
    function resizeCanvas() {
      drawingCanvas.width = drawingCanvas.offsetWidth;
      drawingCanvas.height = drawingCanvas.offsetHeight;
    }
    resizeCanvas();
    window.addEventListener("resize", resizeCanvas);
    drawingCanvas.addEventListener("mousedown", (event) => {
      if (!drawingEnabled) return;
      drawing = true;
      ctx.beginPath();
      const rect = drawingCanvas.getBoundingClientRect();
      const x = event.clientX - rect.left;
      const y = event.clientY - rect.top;
      ctx.moveTo(x, y);
    });
    drawingCanvas.addEventListener("mouseup", () => {
      if (!drawingEnabled) return;
      drawing = false;
      ctx.beginPath();
    });
    drawingCanvas.addEventListener("mousemove", (event) => {
      if (!drawing || !drawingEnabled) return;
      ctx.lineWidth = 2;
      ctx.lineCap = "round";
      ctx.strokeStyle = "red";
      const rect = drawingCanvas.getBoundingClientRect();
      const x = event.clientX - rect.left;
      const y = event.clientY - rect.top;
      ctx.lineTo(x, y);
      ctx.stroke();
    });

    /***************************************************
     * A) OUTILS LEAFLET DRAW
     ***************************************************/
    const drawnItems = new L.FeatureGroup();
    map.addLayer(drawnItems);
    const drawControl = new L.Control.Draw({
      draw: { marker: false, circle: false, circlemarker: false, polygon: true, rectangle: true, polyline: true },
      edit: { featureGroup: drawnItems }
    });
    let measureActive = false;
    const measureButton = document.getElementById("toggleMeasureButton");
    measureButton.addEventListener("click", () => {
      measureActive = !measureActive;
      if (measureActive) { map.addControl(drawControl); measureButton.textContent = "Terminer la mesure"; }
      else { map.removeControl(drawControl); measureButton.textContent = "Mesurer une surface"; }
    });
    function computeBearing(lat1, lng1, lat2, lng2) {
      const toRad = (val) => val * Math.PI / 180;
      const toDeg = (val) => val * 180 / Math.PI;
      const dLon = toRad(lng2 - lng1);
      const y = Math.sin(dLon) * Math.cos(toRad(lat2));
      const x = Math.cos(toRad(lat1)) * Math.sin(toRad(lat2)) - Math.sin(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.cos(dLon);
      let brng = Math.atan2(y, x);
      brng = toDeg(brng);
      return (brng + 360) % 360;
    }
    map.on(L.Draw.Event.CREATED, function (e) {
      const layer = e.layer;
      drawnItems.addLayer(layer);
      if (e.layerType === "polygon" || e.layerType === "rectangle") {
        let latLngs = layer.getLatLngs();
        if (Array.isArray(latLngs[0])) { latLngs = latLngs[0]; }
        const area = L.GeometryUtil.geodesicArea(latLngs);
        const areaInt = Math.round(area);
        alert(`Surface mesurée : ${areaInt.toLocaleString('fr-FR')} m²`);
        document.getElementById("Surface toiture").value = areaInt;
        updateProductionPotential();
      } else if (e.layerType === "polyline") {
        const latLngs = layer.getLatLngs();
        if (latLngs.length < 2) { alert("Tracez au moins 2 points pour la ligne d'orientation."); return; }
        const first = latLngs[0];
        const last = latLngs[latLngs.length - 1];
        const angle = computeBearing(first.lat, first.lng, last.lat, last.lng);
        let aspectVal = angle - 180;
        aspectVal = (aspectVal + 180 + 360) % 360 - 180;
        document.getElementById("orientationIrr").value = aspectVal.toFixed(1);
        document.getElementById("orientation").value = aspectVal.toFixed(1);
        alert(`Orientation déterminée: ${aspectVal.toFixed(1)}° (0 = Sud)`);
        drawnItems.removeLayer(layer);
      }
    });

    /***************************************************
     * 3) RECHERCHE D'ADRESSE + MARQUEUR + TERRITOIRE
     ***************************************************/
    const addressSearchBtn = document.getElementById("addressSearchBtn");
    addressSearchBtn.addEventListener("click", searchAddress);
    function searchAddress() {
      const address = document.getElementById("address").value;
      if(!address) return;
      fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(address)}`)
        .then(r => r.json())
        .then(data => {
          if(data.length > 0){
            const { lat, lon, display_name } = data[0];
            map.setView([lat, lon], 18);
            AdresseField.value = address;
            if(searchMarker){ map.removeLayer(searchMarker); }
            searchMarker = L.marker([lat, lon]).addTo(map);
            searchMarker.bindPopup(`Adresse trouvée : ${address}`).openPopup();
            document.getElementById("latitudeIrr").value = lat;
            document.getElementById("longitudeIrr").value = lon;
            let foundCP = null;
            if(data[0].address && data[0].address.postcode){ foundCP = data[0].address.postcode; }
            else {
              const patternCP = /\b(\d{4,5})\b/;
              let match = display_name.match(patternCP);
              if(match) foundCP = match[1];
            }
            if(foundCP){
              const territoryValue = detectTerritoryFromZip(foundCP);
              document.getElementById("territory").value = territoryValue;
            } else { document.getElementById("territory").value = "France Metropolitaine"; }
          } else { alert("Adresse introuvable."); }
        })
        .catch(err => {
          console.error("Erreur recherche adresse:", err);
          alert("Une erreur est survenue lors de la recherche de l'adresse.");
        });
    }

    /***************************************************
     * 3B) CALCUL PRODUCTIBLE (API PVGIS)
     ***************************************************/
    async function getProductible(lat, lon, aspectValue){
      const angleValue = parseFloat(document.getElementById("angleIrr").value) || 35;
      const originalUrl = `https://re.jrc.ec.europa.eu/api/v5_2/PVcalc?outputformat=basic&lat=${lat}&lon=${lon}&raddatabase=PVGIS-SARAH2&peakpower=1&loss=14&pvtechchoice=crystSi&angle=${angleValue}&aspect=${aspectValue}&usehorizon=1`;
      const proxyUrl = `https://corsproxy.io/?key=a32495b2&url=${encodeURIComponent(originalUrl)}`;
      try {
        const response = await fetch(proxyUrl);
        if(!response.ok) return null;
        const text = await response.text();
        const lines = text.split("\n");
        let yearProduction = null;
        let tempMonthly = [];
        for(let line of lines){
          let cleanLine = line.trim();
          if(!cleanLine) continue;
          if(cleanLine.includes("Year")){
            const parts = cleanLine.split("\t").map(s => s.trim());
            yearProduction = parseFloat(parts[1]);
          }
          else if(/^\d+\s/.test(cleanLine)){
            const parts = cleanLine.split("\t").map(s => s.trim());
            if(parts.length >= 3){
              const monthNumber = parseInt(parts[0], 10);
              const E_mValue = parseFloat(parts[2]);
              tempMonthly.push({month: monthNumber, E_m: E_mValue});
            }
          }
        }
        monthlyProductionData = tempMonthly;
        return {yearProduction, monthlyProduction: tempMonthly};
      } catch(e){
        console.error(e);
        return null;
      }
    }

    const calculateIrrButton = document.getElementById("calculateIrrButton");
    calculateIrrButton.addEventListener("click", async () => {
      const lat = parseFloat(document.getElementById("latitudeIrr").value);
      const lon = parseFloat(document.getElementById("longitudeIrr").value);
      const aspectValue = parseFloat(document.getElementById("orientation").value);
      if(isNaN(lat) || isNaN(lon)){
        alert("Veuillez d'abord renseigner la latitude et la longitude.");
        return;
      }
      const result = await getProductible(lat, lon, aspectValue);
      if(result && result.yearProduction !== null){
        document.getElementById("productible").value = result.yearProduction.toLocaleString('fr-FR');
        fillMonthlyProductionTable(result.monthlyProduction);
      } else { alert("Impossible de récupérer le productible. Vérifiez la connexion ou les données."); }
      updateProductionPotential();
    });

    function fillMonthlyProductionTable(monthlyData){
      const tableBody = document.querySelector("#monthlyProductionTable tbody");
      tableBody.innerHTML = "";
      const moisNoms = ["Janvier","Février","Mars","Avril","Mai","Juin","Juillet","Août","Septembre","Octobre","Novembre","Décembre"];
      monthlyData.forEach(item => {
        const row = document.createElement("tr");
        const monthCell = document.createElement("td");
        const productionCell = document.createElement("td");
        const idx = item.month - 1;
        monthCell.textContent = (idx >= 0 && idx < 12) ? moisNoms[idx] : `Mois ${item.month}`;
        productionCell.textContent = item.E_m?.toLocaleString('fr-FR') || "-";
        row.appendChild(monthCell);
        row.appendChild(productionCell);
        tableBody.appendChild(row);
      });
    }

    /***************************************************
     * 3C) CALCUL "POTENTIEL DE PRODUCTION"
     ***************************************************/
    function updateProductionPotential(){
      const surfaceStr = (document.getElementById("Surface toiture").value || "").replace(/\s/g, "").replace(/\./g, "").replace(/,/g, ".");
      const exclStr = document.getElementById("exclusionPercent").value || "0";
      const panelPowerStr = document.getElementById("puissancePanneau").value || "420";
      const productibleStr = (document.getElementById("productible").value || "").replace(/\s/g, "").replace(/\./g, "").replace(/,/g, ".");
      const surface = parseFloat(surfaceStr) || 0;
      const exclusionPercent = parseFloat(exclStr) || 0;
      const panelPower = parseFloat(panelPowerStr) || 420;
      const productibleVal = parseFloat(productibleStr) || 0;
      const surfaceUtile = surface * (1 - (exclusionPercent/100));
      const nbPanels = Math.floor(surfaceUtile / 2);
      const puissanceMaxW = nbPanels * panelPower;
      const puissanceMaxKW = Math.round(puissanceMaxW / 1000);
      const production = Math.round(puissanceMaxKW * productibleVal);
      document.getElementById("nombrePVMax").value = nbPanels.toLocaleString('fr-FR');
      document.getElementById("puissanceMaxPV").value = puissanceMaxKW.toLocaleString('fr-FR');
      document.getElementById("productionInstall").value = production.toLocaleString('fr-FR');
    }
    const surfaceInput = document.getElementById("Surface toiture");
    const exclInput = document.getElementById("exclusionPercent");
    const panelSelect = document.getElementById("puissancePanneau");
    const productibleInput = document.getElementById("productible");
    surfaceInput.addEventListener("input", updateProductionPotential);
    exclInput.addEventListener("input", updateProductionPotential);
    panelSelect.addEventListener("change", updateProductionPotential);
    productibleInput.addEventListener("input", updateProductionPotential);

    /***************************************************
     * PARTIE : EXPORT PDF AVEC CAPTURE CARTE
     ***************************************************/
    const mapCaptureFileInput = document.getElementById("mapCaptureFile");
    const exportPDFBtn = document.getElementById("exportPDFBtn");
    let mapCaptureDataURL = null;
    let mapCaptureFormat = null;
    mapCaptureFileInput.addEventListener("change", (event) => {
      const file = event.target.files[0];
      if (!file) { mapCaptureDataURL = null; mapCaptureFormat = null; return; }
      const reader = new FileReader();
      reader.onload = (e) => {
        mapCaptureDataURL = e.target.result;
        if (file.type.toLowerCase().includes("jpeg")) { mapCaptureFormat = "JPEG"; }
        else if (file.type.toLowerCase().includes("png")) { mapCaptureFormat = "PNG"; }
        else { mapCaptureFormat = "PNG"; }
        alert("Capture de carte sélectionnée !");
      };
      reader.readAsDataURL(file);
    });
    exportPDFBtn.addEventListener("click", exportStudyReportPDF);
    async function exportStudyReportPDF(){
      try {
        if (!mapCaptureDataURL) {
          alert("Veuillez sélectionner la capture de la carte avant de générer le PDF.");
          return;
        }
        const drawingCanvas = document.getElementById("drawingCanvas");
        let drawingCanvasParent = null;
        if (drawingCanvas) {
          drawingCanvasParent = drawingCanvas.parentNode;
          drawingCanvasParent.removeChild(drawingCanvas);
        }
        const { jsPDF } = window.jspdf;
        const pdf = new jsPDF("p", "mm", "a4");
        const pageWidth = pdf.internal.pageSize.getWidth();
        pdf.setFillColor(0, 92, 160);
        pdf.rect(0, 0, pageWidth, 25, "F");
        const frhProLogoUrl = "https://raw.githubusercontent.com/m2arek/parallele/main/frh_pro_logo.png";
        const frhProLogo = new Image();
        frhProLogo.crossOrigin = "Anonymous";
        frhProLogo.src = frhProLogoUrl;
        await new Promise((resolve) => { frhProLogo.onload = resolve; });
        pdf.addImage(frhProLogo, "PNG", 10, 5, 30, 30);
        pdf.setTextColor(255, 255, 255);
        pdf.setFontSize(22);
        pdf.text("FRH PRO", pageWidth / 2, 17, { align: "center" });
        pdf.setTextColor(0, 0, 0);
        pdf.setFontSize(16);
        const companyName = document.getElementById("companyName")?.value || "";
        const mainTitle = `Rapport d'étude photovoltaïque\n${companyName}`;
        const titleLines = pdf.splitTextToSize(mainTitle, pageWidth - 20);
        pdf.text(titleLines, pageWidth / 2, 40, { align: "center" });
        let yPos = 50;
        const imgTemp = new Image();
        imgTemp.src = mapCaptureDataURL;
        await new Promise((resolve) => { imgTemp.onload = resolve; });
        const pdfWidth = pageWidth - 30;
        const ratio = imgTemp.height / imgTemp.width;
        const pdfHeight = pdfWidth * ratio;
        pdf.addImage(mapCaptureDataURL, mapCaptureFormat, 15, yPos, pdfWidth, pdfHeight);
        yPos += pdfHeight + 10;
        pdf.setFontSize(12);
        const addressVal = document.getElementById("address")?.value || "";
        const latVal = document.getElementById("latitudeIrr")?.value || "";
        const lonVal = document.getElementById("longitudeIrr")?.value || "";
        const productibleVal = document.getElementById("productible")?.value || "";
        pdf.text(`Client : ${companyName}`, 15, yPos);
        yPos += 6;
        pdf.text(`Adresse : ${addressVal}`, 15, yPos);
        yPos += 6;
        pdf.text(`Coordonnées : lat=${latVal}, lon=${lonVal}`, 15, yPos);
        yPos += 6;
        pdf.text(`Productible : ${parseFloat(productibleVal).toLocaleString("fr-FR")} kWh/kWc/an`, 15, yPos);
        yPos += 10;
        let scenarioChoice = prompt(
          "Choisir la préconisation à utiliser dans le rapport\n" +
          "'1' => Préconisation standard\n" +
          "'2' => Préconisation Sélection"
        );
        if(!scenarioChoice) return;
        scenarioChoice = scenarioChoice.trim();
        let monthlyTableId, monthlyChartId, twentyYearsId;
        let puissanceId, coutInstId, primeId, coutReelId, gainSansId, gainAvecId, roiId;
        if (scenarioChoice === "2") {
          monthlyTableId   = "preconisationMonthlyTableForced";
          monthlyChartId   = "monthlyBarChartForced";
          twentyYearsId    = "preconisationTableForced";
          puissanceId      = "puissanceRecoForced";
          coutInstId       = "coutInstallationForced";
          primeId          = "primeValueForced";
          coutReelId       = "coutReelInstallationForced";
          gainSansId       = "gainSansInvForced";
          gainAvecId       = "gainAvecInvForced";
          roiId            = "roiResultForced";
        } else {
          monthlyTableId   = "preconisationMonthlyTable";
          monthlyChartId   = "monthlyBarChart";
          twentyYearsId    = "preconisationTable";
          puissanceId      = "puissanceReco";
          coutInstId       = "coutInstallation";
          primeId          = "primeValue";
          coutReelId       = "coutReelInstallation";
          gainSansId       = "gainSansInv";
          gainAvecId       = "gainAvecInv";
          roiId            = "roiResult";
        }
        await page2_TableauEtGraphique(pdf, scenarioChoice);
        function drawVectorBarChart(pdf, chartX, chartY, chartWidth, chartHeight, moisLabels, consoData, autoData, revData) {
          const allValues = [...consoData, ...autoData, ...revData];
          const maxValue = Math.max(...allValues, 0);
          if (maxValue <= 0) {
            pdf.setFontSize(12);
            pdf.text("Pas de données valides pour tracer le graphique.", chartX, chartY + 10);
            return;
          }
          const nbGridLines = 5;
          const stepValue = maxValue / nbGridLines;
          const stepHeight = chartHeight / nbGridLines;
          pdf.setDrawColor(200, 200, 200);
          pdf.setLineWidth(0.2);
          pdf.setFontSize(8);
          for (let i = 0; i <= nbGridLines; i++) {
            const y = chartY + chartHeight - i * stepHeight; 
            pdf.line(chartX, y, chartX + chartWidth, y);
            const val = i * stepValue;
            const labelStr = Math.round(val).toLocaleString() + " kWh";
            pdf.text(labelStr, chartX - 2, y, { align: "right" });
          }
          const nbMois = moisLabels.length;
          const groupWidth = chartWidth / nbMois;
          const barWidth = groupWidth / 3;
          const colorConso = [255, 159, 159];
          const colorAuto = [159, 235, 159];
          const colorRev = [159, 189, 255];
          pdf.setFontSize(7);
          for (let i = 0; i < nbMois; i++) {
            const baseX = chartX + i * groupWidth;
            const baseY = chartY + chartHeight;
            const hConso = (consoData[i] / maxValue) * chartHeight;
            pdf.setFillColor(...colorConso);
            pdf.rect(baseX, baseY - hConso, barWidth, hConso, "F");
            const hAuto = (autoData[i] / maxValue) * chartHeight;
            pdf.setFillColor(...colorAuto);
            pdf.rect(baseX + barWidth, baseY - hAuto, barWidth, hAuto, "F");
            const hRev = (revData[i] / maxValue) * chartHeight;
            pdf.setFillColor(...colorRev);
            pdf.rect(baseX + 2 * barWidth, baseY - hRev, barWidth, hRev, "F");
            pdf.setTextColor(0, 0, 0);
            pdf.text(moisLabels[i], baseX + barWidth, baseY + 3, { align: "center" });
          }
          pdf.setFontSize(9);
          pdf.text("kWh", chartX + 2, chartY + 5);
        }
        async function page2_TableauEtGraphique(pdf, scenarioChoice) {
          pdf.addPage();
          pdf.setFontSize(14);
          pdf.setTextColor(40, 40, 40);
          pdf.text("Détails par mois (année 1)", 10, 15);
          let nextY = 20;
          let monthlyTableId;
          if (scenarioChoice === "2") { monthlyTableId = "preconisationMonthlyTableForced"; }
          else { monthlyTableId = "preconisationMonthlyTable"; }
          const monthlyTableEl = document.getElementById(monthlyTableId);
          if (monthlyTableEl) {
            pdf.autoTable({
              html: monthlyTableEl,
              startY: nextY,
              styles: { fontSize: 8, cellPadding: 2 },
              headStyles: { fillColor: [0, 92, 160], textColor: 255, fontSize: 9 }
            });
            const lastAutoTable = pdf.lastAutoTable;
            if (lastAutoTable) { nextY = lastAutoTable.finalY + 10; }
          } else {
            pdf.setFontSize(12);
            pdf.text("Aucun tableau mensuel trouvé.", 10, 25);
            nextY = 35;
          }
          const moisLabels = [];
          const consoData = [];
          const autoData = [];
          const revData = [];
          if (monthlyTableEl) {
            const rows = monthlyTableEl.querySelectorAll("tbody tr");
            rows.forEach((tr) => {
              const tds = tr.querySelectorAll("td");
              if (tds.length >= 5) {
                const moisTxt = tds[0].textContent.trim();
                const cVal = parseFloat(tds[1].textContent) || 0; 
                const aVal = parseFloat(tds[3].textContent) || 0;
                const rVal = parseFloat(tds[4].textContent) || 0;
                moisLabels.push(moisTxt);
                consoData.push(cVal);
                autoData.push(aVal);
                revData.push(rVal);
              }
            });
          }
          pdf.setFontSize(14);
          pdf.text("Graphique (Détails par mois)", 10, nextY);
          nextY += 10;
          drawVectorBarChart(pdf, 15, nextY, 170, 70, moisLabels, consoData, autoData, revData);
          nextY += 95;
        }
        pdf.addPage();
        pdf.setFontSize(14);
        pdf.setTextColor(40, 40, 40);
        pdf.text("Projection sur 20 ans", 10, 15);
        let nextY3 = 20;
        const twentyTableEl = document.getElementById(twentyYearsId);
        if (twentyTableEl) {
          pdf.autoTable({
            html: twentyTableEl,
            startY: nextY3,
            styles: { fontSize: 8, cellPadding: 2 },
            headStyles: { fillColor: [22, 160, 133], textColor: 255, fontSize: 9 }
          });
          const lastAuto = pdf.lastAutoTable;
          if (lastAuto) { nextY3 = lastAuto.finalY + 10; }
        } else {
          pdf.setFontSize(12);
          pdf.text("Aucun tableau de projection trouvé.", 10, nextY3 + 5);
          nextY3 += 15;
        }
        pdf.setFontSize(14);
        pdf.text("Chiffres Clés", 10, nextY3);
        nextY3 += 8;
        pdf.setFontSize(12);
        const pReco = document.getElementById(puissanceId)?.textContent || "-";
        const cInst = document.getElementById(coutInstId)?.textContent || "-";
        const cPrime = document.getElementById(primeId)?.textContent || "-";
        const cReel = document.getElementById(coutReelId)?.textContent || "-";
        const gSans = document.getElementById(gainSansId)?.textContent || "-";
        const gAvec = document.getElementById(gainAvecId)?.textContent || "-";
        const roiVal = document.getElementById(roiId)?.textContent || "-";
        pdf.text(`Puissance préconisée : ${pReco} kWc`, 10, nextY3); nextY3 += 6;
        pdf.text(`Coût de l'installation : ${cInst} €`, 10, nextY3); nextY3 += 6;
        pdf.text(`Prime : ${cPrime} €`, 10, nextY3); nextY3 += 6;
        pdf.text(`Coût réel de l'installation : ${cReel} €`, 10, nextY3); nextY3 += 6;
        pdf.text(`Gain total (sans inv.) : ${gSans} €`, 10, nextY3); nextY3 += 6;
        pdf.text(`Gain total (avec inv.) : ${gAvec} €`, 10, nextY3); nextY3 += 6;
        pdf.text(`ROI (années) : ${roiVal}`, 10, nextY3);
        nextY3 += 12;
        pdf.setFontSize(12);
        const finalText = 
          "Ce projet photovoltaïque vous apporte des bénéfices financiers tout " +
          "en valorisant votre toiture et en participant à la transition énergétique. " +
          "Grâce à une expertise FRH PRO, vous bénéficiez d'un accompagnement complet " +
          "et de conseils personnalisés pour optimiser votre retour sur investissement.\n\n" +
          "L'autoconsommation et la revente du surplus vous permettent de réduire vos " +
          "factures d'électricité et de profiter d'une source de revenu durable.";
        const finalLines = pdf.splitTextToSize(finalText, 180);
        pdf.text(finalLines, 10, nextY3);
        nextY3 += 20;
        let pdfFileName = "Rapport_Etude.pdf";
        if (companyName) { pdfFileName = `Rapport_${companyName}.pdf`; }
        pdf.save(pdfFileName);
        if (drawingCanvas && drawingCanvasParent) { drawingCanvasParent.appendChild(drawingCanvas); }
      } catch (e) {
        console.error("Erreur exportStudyReportPDF:", e);
        alert("Une erreur s'est produite lors de l'export PDF (voir console).");
      }
    }

    /***************************************************
     * 5) SAUVEGARDER / CHARGER JSON
     ***************************************************/
    const saveButton = document.getElementById("saveToFile");
    const loadFileInput = document.getElementById("loadFromFile");
    const uploadButton = document.getElementById("uploadFile");
    saveButton.addEventListener("click", () => {
      const form = document.getElementById("userForm");
      const rawFormData = new FormData(form);
      const formObject = {};
      rawFormData.forEach((value, key) => {
        if(formObject[key] !== undefined){
          if(!Array.isArray(formObject[key])) { formObject[key] = [formObject[key]]; }
          formObject[key].push(value);
        } else { formObject[key] = value; }
      });
      const center = map.getCenter();
      formObject["mapCenterLat"] = center.lat;
      formObject["mapCenterLng"] = center.lng;
      formObject["mapZoom"] = map.getZoom();
      formObject["canvasImage"] = drawingCanvas.toDataURL();
      const shapesGeoJSON = drawnItems.toGeoJSON();
      formObject["drawnShapes"] = shapesGeoJSON;
      formObject["monthlyProductionData"] = monthlyProductionData;
      const companyName = formObject["companyName"] || "Formulaire";
      const fileName = `Formulaire_${companyName}.json`;
      const jsonString = JSON.stringify(formObject, null, 2);
      const blob = new Blob([jsonString], { type:"application/json" });
      const link = document.createElement("a");
      link.href = URL.createObjectURL(blob);
      link.download = fileName;
      link.click();
    });
    uploadButton.addEventListener("click", () => { loadFileInput.click(); });
    loadFileInput.addEventListener("change", (event) => {
      const file = event.target.files[0];
      if(file){
        const reader = new FileReader();
        reader.onload = e => {
          const jsonData = JSON.parse(e.target.result);
          const form = document.getElementById("userForm");
          Object.keys(jsonData).forEach(key => {
            if(["mapCenterLat","mapCenterLng","mapZoom","canvasImage","drawnShapes","monthlyProductionData"].includes(key)){ return; }
            const dataValue = jsonData[key];
            if(Array.isArray(dataValue)){
              dataValue.forEach(val => {
                const checkbox = form.querySelector(`[name="${key}"][value="${val}"]`);
                if(checkbox){ checkbox.checked = true; }
              });
            } else {
              const input = form.querySelector(`[name="${key}"]`);
              if(input){ input.value = dataValue; }
            }
          });
          if(jsonData["mapCenterLat"] !== undefined && jsonData["mapCenterLng"] !== undefined && jsonData["mapZoom"] !== undefined){
            map.setView([jsonData["mapCenterLat"], jsonData["mapCenterLng"]], jsonData["mapZoom"]);
          }
          if(jsonData["canvasImage"]){
            const image = new Image();
            image.onload = function(){
              ctx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
              ctx.drawImage(image, 0, 0);
            };
            image.src = jsonData["canvasImage"];
          }
          if(jsonData["drawnShapes"]){
            drawnItems.clearLayers();
            L.geoJson(jsonData["drawnShapes"]).eachLayer(layer => {
              drawnItems.addLayer(layer);
            });
          }
          if(jsonData["monthlyProductionData"]){
            monthlyProductionData = jsonData["monthlyProductionData"];
            fillMonthlyProductionTable(monthlyProductionData);
          }
          for(let i = 0; i < 12; i++){ calculateCost(i); }
          updateProductionPotential();
        };
        reader.readAsText(file);
      }
    });

    /***************************************************
     * 6) CALCUL DU COÛT PAR kWh
     ***************************************************/
    function calculateCost(index){
      const eurosInput = document.getElementById(`euros_${index}`);
      const kwhInput = document.getElementById(`kwh_${index}`);
      const costCell = document.getElementById(`costPerKwh_${index}`);
      if(!eurosInput || !kwhInput || !costCell) return;
      const euros = parseFloat(eurosInput.value) || 0;
      const kwh = parseFloat(kwhInput.value) || 0;
      if(kwh > 0){
        const costPerKwh = (euros / kwh).toFixed(2);
        costCell.textContent = `${costPerKwh} €`;
      } else { costCell.textContent = "-"; }
      calculateTotals();
    }
    function calculateTotals(){
      let totalEuros = 0, totalKwh = 0;
      for(let i = 0; i < 12; i++){
        const eurosVal = document.getElementById(`euros_${i}`);
        const kwhVal = document.getElementById(`kwh_${i}`);
        if(!eurosVal || !kwhVal) continue;
        const eVal = parseFloat(eurosVal.value) || 0;
        const kVal = parseFloat(kwhVal.value) || 0;
        totalEuros += eVal;
        totalKwh += kVal;
      }
      const averageCostPerKwh = totalKwh > 0 ? (totalEuros / totalKwh).toFixed(2) : "-";
      const totalEurosCell = document.getElementById("totalEuros");
      const totalKwhCell = document.getElementById("totalKwh");
      const totalCostPerKwhCell = document.getElementById("totalCostPerKwh");
      if(totalEurosCell) totalEurosCell.textContent = totalEuros.toFixed(2).toLocaleString('fr-FR') + " €";
      if(totalKwhCell) totalKwhCell.textContent = totalKwh.toFixed(2).toLocaleString('fr-FR') + " kWh";
      if(totalCostPerKwhCell){
        totalCostPerKwhCell.textContent = averageCostPerKwh !== "-" ? `${averageCostPerKwh} €` : "-";
      }
    }

    /***************************************************
     * 7) CALCUL DE LA PRÉCONISATION
     ***************************************************/
    function costInstallation(S, territory){
      let raw;
      if (S <= 100) { raw = S * ((1.9093 - (0.00659 * S))) * 1000; }
      else { raw = S * 1.15 * 1000; }
      if (territory === "Corse") { raw *= 1.00; }
      else if (territory === "Reunion") { raw *= 1.13; }
      return Math.round(raw / 100) * 100;
    }
    function getClosedDaysFraction() {
      const closedDays = [];
      document.querySelectorAll('input[name="joursConges[]"]:checked').forEach(chk => closedDays.push(chk.value));
      const nbClosed = closedDays.length;
      return nbClosed / 7.0;
    }
    function getTarifRachatAndPrime(S, territory){
      if(!primeTarifsData) {
        console.warn("primeTarifsData introuvable, on retourne par défaut 0.0761 et prime=0");
        return {tarif:0.0761, primeByWc:0};
      }
      const tData = primeTarifsData[territory] || primeTarifsData["France Metropolitaine"];
      let foundTarif = 0.0761;
      let foundPrime = 0;
      if(tData){
        if(Array.isArray(tData.tarif_rachat)){
          for(let range of tData.tarif_rachat){
            if(S >= range.min && S <= range.max){ foundTarif = range.tarif; break; }
          }
        }
        if(Array.isArray(tData.primes)){
          for(let range of tData.primes){
            if(S >= range.min && S <= range.max){ foundPrime = range.montant_euros_par_wc; break; }
          }
        }
      }
      return {tarif: foundTarif, primeByWc: foundPrime};
    }
    function calculateROI(coutInstallation, autoYear1, surplusYear1, primeTotal, annualPriceIncrease) {
      let cumulativeSavings = 0;
      let roiYears = 0;
      while (roiYears < 100) {
        roiYears++;
        let econAuto = autoYear1 * Math.pow(1 + annualPriceIncrease / 100, roiYears - 1);
        let gainsRev = surplusYear1;
        let prime = (roiYears === 2) ? primeTotal : 0;
        let totalYearSavings = econAuto + gainsRev + prime;
        cumulativeSavings += totalYearSavings;
        if (cumulativeSavings >= coutInstallation) { break; }
      }
      return roiYears;
    }
    function computeAutoAndSurplusForPower(S, globalTarif){
      const ratioDStr = document.getElementById("ratioDiurne").value || "50";
      const ratioD = parseFloat(ratioDStr) || 50;
      const fractionClosed = getClosedDaysFraction();
      let totalGain = 0;
      for(let i = 0; i < 12; i++){
        const kwhInput = document.getElementById(`kwh_${i}`);
        const costCell = document.getElementById(`costPerKwh_${i}`);
        if(!kwhInput || !costCell || !monthlyProductionData[i]) continue;
        const consoKwh = parseFloat(kwhInput.value) || 0;
        const p_kWh = parseFloat(costCell.textContent) || 0;
        const E_m1kW = monthlyProductionData[i].E_m || 0;
        const production = S * E_m1kW;
        const forcedSurplus = fractionClosed * production;
        const leftover = production - forcedSurplus;
        const consoKwhDiurne = consoKwh * (ratioD / 100);
        const autoCons = Math.min(leftover, consoKwhDiurne);
        const leftoverAfter = leftover - autoCons;
        const finalSurplus = forcedSurplus + Math.max(leftoverAfter, 0);
        const gainMonth = (autoCons * p_kWh);
        totalGain += gainMonth;
      }
      return totalGain;
    }
    function calculatePreconisationWithPower(S, firstYearGain, territoryObj){
      fillMonthlyPreconisation(S, territoryObj.tarif);
      fill20YearsPreconisation(S, firstYearGain, territoryObj);
    }
    let monthlyBarChart = null;
    function createMonthlyBarChart(labels, consoData, autoData, revData){
      const ctx = document.getElementById("monthlyBarChart").getContext("2d");
      if(monthlyBarChart){ monthlyBarChart.destroy(); }
      monthlyBarChart = new Chart(ctx, {
        type: "bar",
        data: {
          labels,
          datasets: [
            { label: "Conso kWh", data: consoData, backgroundColor: "rgba(255,99,132,0.6)" },
            { label: "Autoconso kWh", data: autoData, backgroundColor: "rgba(75,192,75,0.6)" },
            { label: "Revente kWh", data: revData, backgroundColor: "rgba(54,162,235,0.6)" },
          ]
        },
        options: {
          responsive: true,
          scales: { y: { beginAtZero: true, title: { display: true, text: "kWh" } } }
        }
      });
    }

    // Mise à jour des tableaux de préconisation en ajoutant la colonne "Recettes d'exploitation" (econAuto + gainsRev)
    function fillMonthlyPreconisation(S, globalTarif){
      const showKwh = document.getElementById("showKwhColumns").checked;
      const table = document.getElementById("preconisationMonthlyTable");
      table.innerHTML = "";
      let headerRow = `<tr>
        <th>Mois</th>
        ${ showKwh ? '<th>Conso kWh</th>' : '' }
        ${ showKwh ? '<th>Production kWh</th>' : '' }
        ${ showKwh ? '<th>Autoconso kWh</th>' : '' }
        ${ showKwh ? '<th>Revente kWh</th>' : '' }
        <th>Recettes d'exploitation</th>
        <th>Facture Sans Centrale</th>
        <th>Économies Autoconso</th>
        <th>Facture Avec Centrale</th>
        <th>Gains Revente</th>
        <th>Prime (année 2)</th>
        <th>Total Économies</th>
        <th>Cumul economies</th>
      </tr>`;
      const thead = document.createElement("thead");
      thead.innerHTML = headerRow;
      table.appendChild(thead);
      const tbody = document.createElement("tbody");
      table.appendChild(tbody);
      let footRow = `<tr>
        <th>Totaux</th>
        ${ showKwh ? '<td id="monthlySumKwhConso">-</td>' : '' }
        ${ showKwh ? '<td id="monthlySumProduction">-</td>' : '' }
        ${ showKwh ? '<td id="monthlySumKwhAuto">-</td>' : '' }
        ${ showKwh ? '<td id="monthlySumKwhRevente">-</td>' : '' }
        <td id="monthlySumRecettes">-</td>
        <td id="monthlyTotalSansPv">-</td>
        <td id="monthlyTotalAuto">-</td>
        <td id="monthlyTotalAvecPv">-</td>
        <td id="monthlyTotalRevente">-</td>
        <td id="monthlyTotalPrime">-</td>
        <td id="monthlyTotalEconomies">-</td>
        <td id="monthlyTotalCumul">-</td>
      </tr>`;
      const tfoot = document.createElement("tfoot");
      tfoot.innerHTML = footRow;
      table.appendChild(tfoot);
      
      let sumSansPv = 0, sumAuto = 0, sumRev = 0, sumPrime = 0, sumCumul = 0, sumRecettes = 0;
      let sumKwhConso = 0, sumKwhAuto = 0, sumKwhRev = 0, sumProduction = 0;
      const moisNoms = ["Janvier","Février","Mars","Avril","Mai","Juin","Juillet","Août","Septembre","Octobre","Novembre","Décembre"];
      const fractionClosed = getClosedDaysFraction();
      const ratioD = parseFloat(document.getElementById("ratioDiurne").value) || 50;
      const chartConso = [], chartAuto = [], chartRev = [];
      for(let i = 0; i < 12; i++){
        const eurosStr = document.getElementById(`euros_${i}`)?.value || "0";
        const factureSansPv = parseFloat(eurosStr) || 0;
        const consoKwh = parseFloat(document.getElementById(`kwh_${i}`)?.value) || 0;
        const costText = document.getElementById(`costPerKwh_${i}`)?.textContent || "0";
        const costUnit = parseFloat(costText) || 0;
        if(!monthlyProductionData[i]) continue;
        const E_m1kW = monthlyProductionData[i].E_m || 0;
        const production = S * E_m1kW;
        sumProduction += production;
        const forcedSurplus = fractionClosed * production;
        const leftover = production - forcedSurplus;
        const consoKwhDiurne = consoKwh * (ratioD/100);
        const autoCons = Math.min(leftover, consoKwhDiurne);
        const leftoverAfter = leftover - autoCons;
        const finalSurplus = forcedSurplus + Math.max(leftoverAfter, 0);
        const recettes = autoCons + (parseFloat(document.getElementById(`costPerKwh_${i}`)?.textContent) ? parseFloat(document.getElementById(`costPerKwh_${i}`)?.textContent)*0 : 0);
        // Ici, on récupère recettes = autoCons + gainsRev (mais gainsRev n’est pas directement disponible ici)
        // Pour simplifier, supposons que la valeur de revente est déjà intégrée dans le calcul par l’utilisateur.
        // Vous pourrez adapter cette partie en fonction des données réelles.
        // Dans cet exemple, on va calculer gainsRev de manière similaire à computeAutoAndSurplusForPower :
        const p_kWh = parseFloat(document.getElementById(`costPerKwh_${i}`)?.textContent) || 0;
        const gainsRev = (finalSurplus - autoCons) * p_kWh;
        const recettesExploitation = autoCons + gainsRev;
        
        const row = document.createElement("tr");
        let rowHTML = `<td>${moisNoms[i]}</td>`;
        if(showKwh) { rowHTML += `<td>${consoKwh.toFixed(1)}</td>`; }
        if(showKwh) { rowHTML += `<td>${production.toFixed(1)}</td>`; }
        if(showKwh) { rowHTML += `<td>${autoCons.toFixed(1)}</td>`; }
        if(showKwh) { rowHTML += `<td>${finalSurplus.toFixed(1)}</td>`; }
        rowHTML += `<td>${recettesExploitation.toFixed(2)} €</td>`;
        rowHTML += `<td>${factureSansPv.toFixed(2)} €</td>`;
        rowHTML += `<td>${autoCons.toFixed(2)} €</td>`;
        rowHTML += `<td>${factureSansPv - autoCons.toFixed(2)} €</td>`;
        rowHTML += `<td>${gainsRev.toFixed(2)} €</td>`;
        rowHTML += `<td>${(autoCons + gainsRev).toFixed(2)} €</td>`;
        // Pour simplifier, cumul on ne calcule pas ici
        rowHTML += `<td>-</td>`;
        row.innerHTML = rowHTML;
        tbody.appendChild(row);
        chartConso.push(consoKwh);
        chartAuto.push(autoCons);
        chartRev.push(finalSurplus);
        sumSansPv += factureSansPv;
        sumRecettes += recettesExploitation;
      }
      if(showKwh){
        document.getElementById("monthlySumKwhConso").textContent = sumKwhConso.toFixed(1);
        document.getElementById("monthlySumProduction").textContent = sumProduction.toFixed(1);
        document.getElementById("monthlySumKwhAuto").textContent = sumKwhAuto.toFixed(1);
        document.getElementById("monthlySumKwhRevente").textContent = sumKwhRev.toFixed(1);
      }
      document.getElementById("monthlyTotalSansPv").textContent = sumSansPv.toFixed(2)+" €";
      // Ici, vous pouvez compléter les totaux des autres colonnes…
      createMonthlyBarChart(moisNoms, chartConso, chartAuto, chartRev);
    }
    
    // Pour la préconisation en mode "Sélection" (Forced), on reprend la même structure
    function fill20YearsPreconisation(S, firstYearGain, territoryObj){
      const annualPriceIncrease = parseFloat(document.getElementById("annualPriceIncrease").value) || 5;
      let baseYearStr = document.getElementById("monthlyTotalSansPv").textContent.replace("€","").trim();
      let baseYearCost = parseFloat(baseYearStr) || 0;
      let strEco = document.getElementById("monthlyTotalAuto").textContent.replace("€","").trim();
      let strRev = document.getElementById("monthlyTotalRevente").textContent.replace("€","").trim();
      let autoYear1 = parseFloat(strEco) || 0;
      let surplusYear1 = parseFloat(strRev) || 0;
      const primeByWc = territoryObj.primeByWc || 0;
      const primeTotal = Math.round(primeByWc * (S * 1000));
      const preconTableBody = document.querySelector("#preconisationTable tbody");
      preconTableBody.innerHTML = "";
      let cumulativeEco = 0;
      for(let year = 1; year <= 20; year++){
        const factureSansPv = baseYearCost * Math.pow(1+annualPriceIncrease/100, (year-1));
        const econAuto = autoYear1 * Math.pow(1 - 0.006, (year-1)) * Math.pow(1+annualPriceIncrease/100, (year-1));
        const gainsRev = surplusYear1;
        let primeYear = (year === 2) ? primeTotal : 0;
        const recettesExploitation = econAuto + gainsRev;
        const factureAvecPv = factureSansPv - econAuto;
        const totalEcos = recettesExploitation + primeYear;
        cumulativeEco += totalEcos;
        const row = document.createElement("tr");
        row.innerHTML = `
          <td>${year}</td>
          <td>${recettesExploitation.toFixed(2)} €</td>
          <td>${factureSansPv.toFixed(2)} €</td>
          <td>${econAuto.toFixed(2)} €</td>
          <td>${factureAvecPv.toFixed(2)} €</td>
          <td>${gainsRev.toFixed(2)} €</td>
          <td>${primeYear.toFixed(2)} €</td>
          <td>${totalEcos.toFixed(2)} €</td>
          <td>${cumulativeEco.toFixed(2)} €</td>
        `;
        preconTableBody.appendChild(row);
      }
    }
    
    function fill20YearsPreconisationForced(S, firstYearGain, territoryObj){
      // Structure analogue à fill20YearsPreconisation, à adapter si besoin
      const annualPriceIncrease = parseFloat(document.getElementById("annualPriceIncrease").value) || 5;
      let baseYearStr = document.getElementById("monthlyTotalSansPvForced").textContent.replace("€","").trim();
      let baseYearCost = parseFloat(baseYearStr) || 0;
      let strEco = document.getElementById("monthlyTotalAutoForced").textContent.replace("€","").trim();
      let strRev = document.getElementById("monthlyTotalReventeForced").textContent.replace("€","").trim();
      let autoYear1 = parseFloat(strEco) || 0;
      let surplusYear1 = parseFloat(strRev) || 0;
      const primeByWc = territoryObj.primeByWc || 0;
      const primeTotal = Math.round(primeByWc * (S * 1000));
      const preconTableBody = document.querySelector("#preconisationTableForced tbody");
      preconTableBody.innerHTML = "";
      let cumulativeEco = 0;
      for(let year = 1; year <= 20; year++){
        const factureSansPv = baseYearCost * Math.pow(1+annualPriceIncrease/100, (year-1));
        const econAuto = autoYear1 * Math.pow(1+annualPriceIncrease/100, (year-1));
        const gainsRev = surplusYear1;
        let primeYear = (year === 2) ? primeTotal : 0;
        const recettesExploitation = econAuto + gainsRev;
        const factureAvecPv = factureSansPv - econAuto;
        const totalEcos = recettesExploitation + primeYear;
        cumulativeEco += totalEcos;
        const row = document.createElement("tr");
        row.innerHTML = `
          <td>${year}</td>
          <td>${recettesExploitation.toFixed(2)} €</td>
          <td>${factureSansPv.toFixed(2)} €</td>
          <td>${econAuto.toFixed(2)} €</td>
          <td>${factureAvecPv.toFixed(2)} €</td>
          <td>${gainsRev.toFixed(2)} €</td>
          <td>${primeYear.toFixed(2)} €</td>
          <td>${totalEcos.toFixed(2)} €</td>
          <td>${cumulativeEco.toFixed(2)} €</td>
        `;
        preconTableBody.appendChild(row);
      }
    }

    /***************************************************
     * NOUVELLE FONCTIONNALITÉ : PLAN DE TRÉSORERIE
     ***************************************************/
    const calculatePlanTresorerieBtn = document.getElementById("calculatePlanTresorerieBtn");
    calculatePlanTresorerieBtn.addEventListener("click", () => {
      calculatePlanTresorerie();
    });
    function calculatePlanTresorerie() {
      // Choix du mode de financement
      const modeElems = document.getElementsByName("modeFinancement");
      let modeSelected = "pret";
      for (let i = 0; i < modeElems.length; i++){
        if(modeElems[i].checked){ modeSelected = modeElems[i].value; break; }
      }
      // Choix du scénario de projection à utiliser
      const projElems = document.getElementsByName("projectionScenario");
      let projScenario = "standard";
      for (let i = 0; i < projElems.length; i++){
        if(projElems[i].checked){ projScenario = projElems[i].value; break; }
      }
      // Récupération des paramètres financiers (les valeurs n'incluent plus d'unités)
      const inflationRate = parseFloat(document.getElementById("inflation_estimee").value.replace(",", ".")) || 2.0;
      const assuranceDomRate = parseFloat(document.getElementById("assurance_dommages").value.replace(",", ".")) / 100.0 || 0.002;
      const assurancePerteRate = parseFloat(document.getElementById("assurance_perte").value.replace(",", ".")) / 100.0 || 0.003;
      const coutMaintenance = parseFloat(document.getElementById("cout_maintenance").value.replace(",", ".")) || 5.97;
      const coutChangementOnduleurs = parseFloat(document.getElementById("cout_changement_onduleurs").value.replace(",", ".")) || 0;
      const tauxEmprunt = parseFloat(document.getElementById("taux_emprunt").value.replace(",", ".")) / 100.0 || 0.02;
      const dureePret = parseInt(document.getElementById("duree_pret").value) || 15;
      const indexLeasing = parseFloat(document.getElementById("index_leasing").value.replace(",", ".")) || 1.837;
      const dureeLeasing = parseInt(document.getElementById("duree_leasing").value) || 72;
      // Coût d'installation HT et puissance installée (déjà calculés dans les onglets précédents)
      const costInstallStr = document.getElementById("coutInstallation").textContent || "0";
      const costInstallHT = parseFloat(costInstallStr.replace(/\s/g, "").replace(",", ".")) || 0;
      const Sstr = document.getElementById("puissanceReco").textContent || "0";
      const S = parseFloat(Sstr.replace(/\s/g, "").replace(",", ".")) || 0;
      
      // Lecture du tableau de projection en fonction du scénario choisi
      let projectionTable;
      if(projScenario === "selection") {
        projectionTable = document.getElementById("preconisationTableForced");
      } else {
        projectionTable = document.getElementById("preconisationTable");
      }
      // On lit la colonne "Recettes d'exploitation" (colonne index 1, en partant de 0)
      let recettesArray = [];
      if(projectionTable){
        const rows = projectionTable.querySelectorAll("tbody tr");
        rows.forEach(row => {
          const cells = row.querySelectorAll("td");
          if(cells.length >= 2){
            // Suppression de l'unité "€" et conversion en nombre
            let val = parseFloat(cells[1].textContent.replace("€", "").trim());
            recettesArray.push(isNaN(val) ? 0 : val);
          }
        });
      }
      // Si le tableau de projection n'est pas disponible, on arrête
      if(recettesArray.length === 0){
        alert("Le tableau de projection n'est pas disponible. Veuillez recalculer la préconisation.");
        return;
      }
      
      // Calcul des charges d'exploitation
      // Charges d'exploitation = maintenance + remplacement onduleur(s)
      // Maintenance = S * coutMaintenance * (1+inflationRate/100)^(year-1)
      // Remplacement onduleur(s) = ajouté uniquement en année 11 (sans inflation)
      // Assurance photovoltaïque = costInstallHT * (assuranceDomRate + assurancePerteRate) * (1+inflationRate/100)^(year-1)
      // Total Charges = Charges d'exploitation + Assurance photovoltaïque
      let planTableHTML = `<thead>
        <tr>
          <th>Année</th>
          <th>Recettes d'exploitation</th>
          <th>Charges d'exploitation<br/>(maintenance + remplacement onduleurs)</th>
          <th>Assurance photovoltaïque</th>
          <th>Total Charges d'exploitation</th>`;
      if(modeSelected === "pret"){
        planTableHTML += `<th>Remboursement du prêt<br/>(capital + intérêts)</th>`;
      } else {
        planTableHTML += `<th>Loyer</th>`;
      }
      planTableHTML += `<th>Solde net annuel</th>
        </tr>
      </thead><tbody>`;
      const nbYears = 20;
      
      // Calcul du financement
      let yearlyFinancement = 0;
      if(modeSelected === "pret"){
        const i_mens = tauxEmprunt / 12;
        const n_mois = dureePret * 12;
        yearlyFinancement = n_mois > 0 ? costInstallHT * ( i_mens / (1 - Math.pow(1+i_mens, -n_mois)) ) * 12 : 0;
      } else {
        const nbYearsLeasing = dureeLeasing / 12;
        yearlyFinancement = S > 0 ? costInstallHT * (indexLeasing/100) * 12 : 0;
      }
      
      for(let year = 1; year <= nbYears; year++){
        // Recettes d'exploitation récupérées depuis le tableau de projection
        const recettes = recettesArray[year-1] || 0;
        // Maintenance et remplacement
        const maintenance = S * coutMaintenance * Math.pow(1 + inflationRate/100, year-1);
        const remplacement = (year === 11) ? coutChangementOnduleurs : 0;
        const chargesExploitation = maintenance + remplacement;
        // Assurance photovoltaïque
        const assurance = costInstallHT * (assuranceDomRate + assurancePerteRate) * Math.pow(1 + inflationRate/100, year-1);
        const totalCharges = chargesExploitation + assurance;
        // Financement
        let financement = 0;
        if(modeSelected === "pret"){
          financement = (year <= dureePret) ? yearlyFinancement : 0;
        } else {
          const nbYearsLeasing = dureeLeasing / 12;
          financement = (year <= nbYearsLeasing) ? yearlyFinancement : 0;
        }
        const soldeNet = recettes - (totalCharges + financement);
        planTableHTML += `<tr>
          <td>${year}</td>
          <td>${recettes.toFixed(2)} €</td>
          <td>${chargesExploitation.toFixed(2)} €</td>
          <td>${assurance.toFixed(2)} €</td>
          <td>${totalCharges.toFixed(2)} €</td>
          <td>${financement > 0 ? financement.toFixed(2) + " €" : "-"}</td>
          <td>${soldeNet.toFixed(2)} €</td>
        </tr>`;
      }
      planTableHTML += `</tbody>`;
      document.getElementById("planTresorerieTable").innerHTML = planTableHTML;
    }

    /***************************************************
     * FIN NOUVELLE FONCTIONNALITÉ : PLAN DE TRÉSORERIE
     ***************************************************/

    flatpickr("#rdvDate", { locale: "fr", dateFormat: "d/m/Y" });
  </script>
</body>
</html>
